# Week6

[https://www.gdschongik.com/backend-study/subject/6](https://www.gdschongik.com/backend-study/subject/6)

[https://www.notion.so/Week6-7530e2c261024ab5bfb34fb8d0a9d269?pvs=4](https://www.notion.so/Week6-7530e2c261024ab5bfb34fb8d0a9d269)

# **<필수 정리 내용>**

# 1. **추상 클래스와 인터페이스**

### 추상 메서드

**: 선언부는 있는데 구현부가 없는 메서드**

→ 추상 메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스로 선언해야 한다.

→  추상 메서드 없이 추상 클래스를 선언 가능하다 ⇒ 몸체 없이 선언만 있는 메서드

## 추상 클래스

: 추상 메서드를 선언하여 **상속을 통해서 자손 클래스에서 완성하도록 유도**하는 클래스

 → 인스턴스, 즉 객체를 만들 수 없다. ⇒ new 사용이 불가능

→ 추상 메서드는 하위 클래스에게 메서드의 구현을 강제한다. → 오버라이딩 강제

→ 추상 메서드를 포함하는 클래스는 반드시 추상 클래스여야 한다.

## 인터페이스

**: 기본 설계도** 

→ 인터페이스는 부모 자식 관계인 상속에 얽매이지 않고, 공통 기능이 필요할 때마다 추상 메서드를 정의해놓고 구현(implement)하는 식으로 추상 클래스보다 자유롭게 사용이 가능하다.

→ 인터페이스는 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하는 것에 초점을 둔다.

→ 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와 달리 다중상속을 받는 것이 가능하다.

**추상 클래스 = 미완성 설계도** 

**인터페이스 = 구현된 것은 아무 것도 없는 밑그림만 그려진 기본 설계도**

**추상 클래스**

: 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로, 상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 부모 클래스가 가진 기능들을 구현해야할 경우 사용한다.

**인터페이스**

:상속 관계를 타고 올라갔을 때 다른 조상 클래스를 상속하더라도, 같은 기능이 필요할 경우 사용한다. 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용한다.

**추가 정리 내용**

**생성자는 원래 객체 생성자 메서드**

**생성자는 개발자가 필요한 만큼 오버로딩해서 만들 수 있다.**

**클래스 생성자는 존재하지 않는다.**

→ 그러나 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록이 있다 ⇒ static블록

**추상클래스와 인터페이스 모두 추상메서드를 사용할 수 있다**

# 2. **static과 final 그리고 불변 객체**

## static

→ static 블록에서 사용할 수 있는 속성과 메서드는 static멤버 뿐이다. 

→ 객체 멤버는 클래스가 static블록에 실행되고 있을 떄는 해당 클래스의 객체는 하나도 존재하지 않기 때문에 static블록에서는 객체 멤버에 접근할 수 없다.

→ 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 T 메모리의 static 영역에 로딩되며 이때 단 한번 해당 클래스의 static 블록이 실행된다. 여기서 클래스가 제일 처음 사용될 때는 다음 세 가지 경우 중 하나이다

- 클래스의 정적 속성을 사용할 때
- 클래스의 정적 메서드를 사용할 때
- 클래스의 인스턴스를 최초로 만들 때

## final

**final키워드가 나타날 수 있는 곳 = 클래스 + 변수 + 메서드**

- **클래스에 final이 붙으면 상속을 허락하지 않겠다는 의미를 가진다.**

→  하위 클래스를 만들 수 없다.

- **변수에 final이 붙으면 변경 불가능한 상수가 된다.**

→ 정적 상수는 선언 시에, 또는 정적 생성자에 해당하는 static 블록 내부에서 초기화가 가능하다. 

객체 상수 역시 선언 시에, 또는 객체 생성자 또는 인스턴스 블록에서 초기화할 수 있다. 지역 상수 역시 선언 시에 또는 최초 한 번만 초기화가 가능하다.

(+ 다른 언어에서는 읽기 전용인 상수에 대해 final 대신 constant 키워드를 사용하기도 하는데 자바에서는 이런 혼동을 피하기 위해 const를 키워드로 등록해두고 쓰지 못하게 하고 있다.)

- **메서드에 final이 붙으면  오버라이딩을 금지하게 된다.**

## 불변 객체

**: 생성 후 그 상태를 바꿀 수 없는 객체**

→ 불변 객체를 사용하면 복제나 비교를 위한 조작을 단순화 할 수 있고, 성능 개선에도 도움을 준다.

객체가 변경 가능한 데이터를 많이 가지고 있는 경우엔 불변이 오히려 부적절한 경우가 있다.

→ 불변 객체는 read-only 메소드만을 제공하며, 객체의 내부 상태를 제공하는 메소드를 제공하지 않거나 방어적 복사(defensive-copy)를 통해 제공한다.

→ 대표적인 불변 객체 : string

# **<선택 정리 내용>**

1. **static 으로 선언한 변수의 초기화 시점에 관한 아래 문항에 답하시오.**

**(1) 일반적인 인스턴스 변수들은 객체 생성 시에 초기화된다. static 변수도 동일할 지에 대해 서술하시오.**

→ static 변수는 인스턴스의 생성과 상관 없이 초기화된다. JVM에 의해 클래스가 메모리 공간에 올라가는 순간 변수가 초기화된다. 

**(2) [심화] JVM 의 동작 원리를 살펴보며, 이중에서 static 변수가 초기화되는 시점을 특정하시오.** 

![img1.daumcdn.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3fb23136-c159-4b59-8441-6dbda5787250/img1.daumcdn.png)

→ 클래스 로드 과정 중 초기화 화정에서 블래스 변수들이 적절한 값으로 초기화되는데, 이때 static 변수가 초기화된다.

1. **불변 객체의 장단점을 정리하시오.**

**장점**

- 객체에 대한 신뢰도가 높아진다.
- 외부에서 객체에 대해 변경할 수 없기 때문에 안정성이 있다.
- 생성자, 접근메소드에 대한 방어 복사가 필요없다.
- 가비지 컬렉션의 성능을 높일 수 있다.


**단점**

- 객체가 가지는 값마다 새로운 객체가 필요하다.
- 메모리 누수와 새로운 객체를 계속 생성해야하기 때문에 성능저하를 발생시킬 수 있다.

[https://myjamong.tistory.com/150](https://myjamong.tistory.com/150)

[https://velog.io/@conatuseus/Java-Immutable-Object불변객체](https://velog.io/@conatuseus/Java-Immutable-Object%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4)

[https://velog.io/@new_wisdom/Java-추상-클래스와-인터페이스의-차이](https://velog.io/@new_wisdom/Java-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4)

[https://devoong2.tistory.com/entry/Java-불변-객체Immutable-Object-에-대해-알아보자](https://devoong2.tistory.com/entry/Java-%EB%B6%88%EB%B3%80-%EA%B0%9D%EC%B2%B4Immutable-Object-%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)

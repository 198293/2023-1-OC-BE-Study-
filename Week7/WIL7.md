# WEEK7

[https://www.gdschongik.com/backend-study/subject/7](https://www.gdschongik.com/backend-study/subject/7)

[https://www.notion.so/WEEK7-3bcfe4a92a13440c8b6f8efc4c4434c1?pvs=4](https://www.notion.so/WEEK7-3bcfe4a92a13440c8b6f8efc4c4434c1)

# SOLID (객체 지향 설계 5원칙)

### SRP + OCP + LSP + ISP + DIP

**(단일 책임 원칙 + 개방 폐쇄 원칙 + 리스코프 치환 원칙 + 인터페이스 분리 원칙 + 의존 역전 원칙)**

**: 객체 지향을 올바르게 프로그램에 녹여내기 위한 원칙**

→**객체 지향 4대 특성을 제대로 활용한 결과로 당연히 나타나는 것.**

**→ 응집도는 높이고, 결합도는 낮추라는 고전 원칙을 객체 지향의 관점에서 재정립한 것.**

### SOLID 특징

→ **결합도는 모듈(클래스) 간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.** 

→ **응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈을 하나의 책임에 집중하고 독힙성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.**

→ **SOLID를 잘 녹여낸 소프트웨어는 그렇지 않은 소프트웨어에 비해 상대적으로 이해하기 쉽고, 리팩터링과 유지보수가 수월할 뿐만 아니라 논리적으로 정연하다.** 

→ **SOLID 원칙을 적용하면 소스 파일의 개수는 더 많아지는 경향이 있다. 하지만 이렇게 많아진 파일이 논리를 더욱 잘 분할하고, 잘 표현하기에 이해하기 쉽고, 개발하기 쉬우며, 유지와 관리, 보수하기 쉬운 소스가 만들어진다.**

## **단일 책임 원칙(SRP)의 개념과 해당 원칙이 적용되었을 때의 장점**

**⇒ 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이여야 한다**

**:  속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에도 적용할 수 있는 개념이다.** 

**→ 단일 책임 원칙과 가장 관계가 깊은 것은 모델링 과정을 담당하는 추상화이다.**                 

### 장점

- **한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄작용**에서 자유로울 수 있게 된다.
- 책임을 적절히 분배함으로써 **코드의 가독성** 향상, **유지보수 용이**라는 이점까지 누릴 수 있다.
- 단일 책임 원칙은 다른 **설계 원리들을 적용하는 기초**가 된다.

## **개방 폐쇄 원칙(OCP)의 개념과 해당 원칙이 적용되었을 때의 장점**

**⇒ 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀있어야 한다.**

### 장점

- **다형성**과 **확장**을 가능케 하는 **객체지향의 장점을 극대화**한다.

→  클래스를 추가해야한다면 기존 코드를 크게 **수정할 필요없이**,  **유연하게 확장**할 수 있다.

- **객체의 모듈화와 정보 은닉의 올바른 구현**을 추구하며, 이를 통해 **객체 간의 의존성을 최소화**하여 코드 변경에 따른 영향력을 낮출 수 있다.

### 특징

- **개방 폐쇄 원칙을 무시하고 프로그램을 작성하면 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다.**
- **자바의 경우도 개방 폐쇄 원칙이 적용되어 있다.**

**→ 운영체제별 JVM과 목적 파일을 통해 다양한 운영체제에서 소스코드를 구현할 수 있다.**

## **리스코프 치환 원칙(LSP)의 개념과 해당 원칙이 적용되었을 때의 장점**

**⇒ 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.**

→  **“하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.”**

- **개층도/ 조직도를 보았을 때 하위에 존재하는 것들이 상위에 있는 것들의 역할을 하는 데 전혀 문제가 없다.**
    
    **하위 클래스 is a kind of  상위 클래스 - 하위 분류는 상위 분류의 한 종류다.**
    
    **구현 클래스 is able to 인터페이스 - 구현 분류는 [인터페이스명] 할 수 있어야 한다.**
    

→ **위 두 개의 문장대로 구현된 프로그램이라면 이미 리스코프 치화 ㄴ원칙을 잘 지키고 있다고 할 수 있다.** 

**리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것이다.**

**장점 : 리스코프 치환 원칙을 통해 다형성을 지원할 수 있다.**

## **인터페이스 분리 원칙(ISP)의 개념과 해당 원칙이 적용되었을 때의 장점**

**⇒ 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.**

- **SRP처럼 클래스는 역할에 따라 토막 내는 것이 아니라 다중 인격화시키는 것이라고 생각하면 쉽다.**
- **단일 책임 원칙과 인터페이스 분할 원칙은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.**
    
    → **프로젝트의 요구사항과 설계자의 취향에 따라 단일 책임 원칙이나 인터페이스 분할 원칙 중 하나를 선택해서 설계할 수 있다. 하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.** 
    

### 장점

- 큰 덩어리의 인터페이스를 구체적이고 **작은 단위로 분리**시키며 클라이언트가 꼭 필요한 메서드만 이용할 수 있게 한다.
- 인터페이스를 잘게 나눔으로써 **클래스의 기능을 쉽게 파악**할 수 있으며, **유연하게 객체의 기능을 확장**하거나 **수정**할 수 있다.

## **의존 역전 원칙(DIP)의 개념과 해당 원칙이 적용되었을 때의 장점**

**⇒ 자신보다 변하기 쉬운 것에 의존하지 마라**

**: 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것**

> ***“고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.”***
> 

> ***“추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다. ”***
> 

> ***“자주 변경되는 구체(contrete) 클래스에 의존하지 마라” - 로버트 C.마틴***
> 

- **상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않은 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스,  인터페이스, 추상 클래스를 통해 의존하라는 것이 바로 의존 역전 원칙이다.**

**장점 : DIP를 지키면 종속성을 줄일 수 있기 때문에 유지관리 및 수정이 쉬운 코드를 작성할 수 있다.**

[https://inpa.tistory.com/entry/OOP-💠-아주-쉽게-이해하는-SRP-단일-책임-원칙](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-SRP-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99)

[https://inpa.tistory.com/entry/OOP-💠-아주-쉽게-이해하는-OCP-개방-폐쇄-원칙#:~:text=개방 폐쇄의 원칙](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-OCP-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99#:~:text=%EA%B0%9C%EB%B0%A9%20%ED%8F%90%EC%87%84%EC%9D%98%20%EC%9B%90%EC%B9%99)(OCP,%ED%95%9C%EB%8B%A4%EB%8A%94%20%EC%9D%98%EB%AF%B8%EB%A1%9C%20%EC%A0%95%EC%9D%98%ED%95%9C%EB%8B%A4.

[https://blog.itcode.dev/posts/2021/08/14/open-closed-principle](https://blog.itcode.dev/posts/2021/08/14/open-closed-principle)

[https://inpa.tistory.com/entry/OOP-💠-아주-쉽게-이해하는-ISP-인터페이스-분리-원칙](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-ISP-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99)

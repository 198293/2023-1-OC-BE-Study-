# WEEK8

https://www.gdschongik.com/backend-study/subject/8

[https://www.notion.so/WEEK8-2d0c6f9775d74543b137658529314ea7?pvs=4](https://www.notion.so/WEEK8-2d0c6f9775d74543b137658529314ea7)

## **IoC와 프레임 워크, 라이브러리**

### **IoC**

**: inversion of control = 제어의 역전**

→ 작성한 메서드나 객체의 호출을 개발자가 결정하는 것이 아닌 외부, 즉 스프링 프레임워크에서 이루어지게 되는데 이것을 제어의 역전(IoC)이라고 한다.

→ 객체 호출에 대한 제어권이 **프레임워크**에 있기 때문에 **DI(의존성 주입)**이 가능하다.

### DI(Dependency Injection)

**: 의존성 주입**

→ 스프링 프레임워크가 제공하는 특별한 기능으로 객체를 직접 생성하여 사용하는 게 아닌, **스프링 프레임워크에게 주입**받아 사용하는 기능

→ 세 가지 방법이 있다(**필드 주입 +  수정자 주입 + 생성자 주입**)

### **스프링 프레임워크(Spring Framework)**

**: 자바(Java) 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크**

→ Application 개발 시 필수 코드, 알고리즘, DB 연동 같은 기능들을 위해 어느정도 **뼈대(구조)**를 제공해주는 것

→ OOP를 하며 일관성 부족 등의 문제를 해결해준다.

**→ 프로그래머가 그 안에 필요한 코드를 작성하는 형태이다.**

### **라이브러리**

: **특정 기능에 대한 도구 or 함수를 모은 집합.**

→ 사용자가 **흐름에 대해 제어**한다

→  프로그래머가 필요한 상황에 가져다 사용한다

## **생성자를 통한 의존성 주입과 @Autowired 비교**

### 생성자 주입

**: 생성자를 통해 의존 관계를 주입하는 방법**

:→ 주입받은 객체가 변하지 않거나, 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용할 수 있다.

→ **단일 생성자**의 경우 **@Autowired** 을 붙이지 않아도 되지만**,** 생성자가 **2개 이상**인 경우 붙여야 한다

### **@Autowired**

: 스프링 컨테이너에 등록한 빈에게 **의존관계주입**이 필요할 때, DI(의존성 주입)을 도와주는 어노테이션

→ 3가지 방법으로 실현이 가능하다. (**생성자, 수정자(setter), 필드**)

**생성자 주입 방법을 더 권장한다**

**→ 순환 참조를 방지할 수 있다.**

**→ 테스트에 용이하다.**

**→ 필드를 final로 선언할 수 있다.**

**→ 오류를 방지할 수 있다.**

**→ 품질 좋은 코드를 만들 수 있다.**

## **AOP(**Aspect Oriented programming**)
:** 관점 지향 프로그래밍

![image.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33761040-684a-4bf5-ad85-7f3c0ff52b2d/image.png)

→ 어떤 로직을 기준으로 **핵심적인 관점**, **부가적인 관점**으로 나눠보고 그 관점을 기준으로 각각 모듈화 하겠다는 의미를 가진다

→ 스프링 DI가 의존성에 대한 주입이라면 스프링 AOP는 로직(code)의 주입이라 할 수 있다.

→ Aspect를 분리하여 핵심기능을 설계 및 구현할 때 **객체지향적인 가치**를 지킬 수 있도록 도와준다.

**다양한 AOP 적용 방법**

- 컴파일
- 바이트코드 조작
- 프록시 패턴

### 1-(1) 의존성 주입 방법에는 어떤 것이 있는지 기재하시오.

- **생성자 주입**

: 생성자를 통해 의존 관계를 주입하는 방법

- **필드 주입**

: 필드에 바로 의존 관계를 주입하는 방법이다.

→가장 편리한 방법이자 실무에서 가장 자주 보이는 주입방법 

- **수정자 주입(Setter Injection)**

: 필드 값을 변경하는 Setter를 통해서 의존 관계를 주입하는 방법

→ Setter 주입은 생성자 주입과 다르게 주입받는 객체가 변경될 가능성이 있는 경우에 사용한다.

- ****일반 메소드 주입(Method Injection)****

: 일반 메소드를 통해 의존 관계를 주입하는 방법

### 1-(2) 여러 의존성 주입 방법중에 private final 문법과 @RequiredArgsConstructor 어노테이션을 사용하여 주입 하는 이점이 무엇일지 쓰시오.

: @RequiredArgsConstructor는 **final 혹은 @NotNull**이 붙은 **필드의 생성자를 자동**으로 만들어준다.

→ 생성자를 만들기 번거롭다는 단점을 보완하기 위해 나타난 **생성자 주입 방식의 코딩**

→ 새로운 필드를 추가할 때 다시 생성자를 만들거나 하는 등의 번거로움을 없앨 수 있다

### 1-(3) @AllArgsConstructor, @NoArgsConstructor는 무엇인지 쓰시오.

- **@AllArgsConstructor**

→ 클래스의 **모든 필드에 대한 생성자**를 자동으로 생성

- **@NoArgsConstructor**

→ 파라미터가 없는 **기본 생성자**를 생성

### 2. AOP를 이용하여 많은 기능을 구현할 수 있다. 대표적인 것을 조사하고 정리하시오.

- **간단한 메소드의 성능 검사**

→ 개발 도중, 특히 DB에 대량을 데이터를 넣고 빼는 등의 작업 시간 측정은 중요하다. 매번 해당 메소드의 처음과 끝에 System.currentTimeMillis(); 메소드를 사용하거나 스프링의 StopWatch 코드를 사용하기엔 번거로우니 이런 경우 해당 작업을 하는 코드를 밖에 설정하는 편이 편리하다.

- **트랜잭션 처리**

→ 트랜잭션의 경우, 비즈니스 로직의 전후에 설정되지만 매번 사용하는 try-catch 부분의 코드는 번거롭고 소스를 복잡하게 만든다.

- **예외 반환**

→ 구조가 좋지 않은 예외들이 발생했을 때, 그것을 잡아서 잘 정의 되어있는 예외 계층 구조(ex.스프링의 DataAccessException)로 변환해 다시 던질 때 편리하다.
